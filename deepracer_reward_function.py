{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import math\n",
    "\n",
    "\n",
    "def distance(location1, location2):\n",
    "    return ((location1[0] - location2[0]) ** 2 + (location1[1] - location2[1]) ** 2) ** 0.5\n",
    "\n",
    "def rectangle(radius, theta):\n",
    "    #param: theta degrees\n",
    "    x = radius * math.cos(math.radians(theta))\n",
    "    y = radius * math.sin(math.radians(theta))\n",
    "    return x, y\n",
    "\n",
    "\n",
    "def angle_modified_360(angle):\n",
    "    \"\"\"\n",
    "    Mapping angles with intervals of -180 to +180 degrees.\n",
    "    \"\"\"\n",
    "\n",
    "    n_degrees = math.floor(angle/360.0)\n",
    "\n",
    "    angle_from_0_and_360 = angle - n_degrees*360.0\n",
    "\n",
    "    if angle_from_0_and_360 <= 180.0:\n",
    "        return angle_from_0_and_360\n",
    "    else:\n",
    "        return angle_from_0_and_360 - 360\n",
    "\n",
    "\n",
    "def polar_coordinates(x, y):\n",
    "    radius = (x ** 2 + y ** 2) ** .5\n",
    "    theta = math.degrees(math.atan2(y,x))\n",
    "    return r, theta\n",
    "\n",
    "\n",
    "def get_ordered_waypoints(params):\n",
    "    # waypoints are given in counter clockwise order\n",
    "    if params['is_reversed']: # reversing waypoints driving clock wise\n",
    "        return list(reversed(params['waypoints']))\n",
    "    else: # driving counter clock wise.\n",
    "        return params['waypoints']\n",
    "\n",
    "\n",
    "def up_sampling(waypoints, factor):\n",
    "    #Adding an extra waypoint between waypoints enhancing accuracy\n",
    "\n",
    "    point = waypoints\n",
    "    number = len(p)\n",
    "\n",
    "    return [[i / factor * point[(j+1) % number][0] + (1 - i / factor) * point[j][0],\n",
    "             i / factor * point[(j+1) % number][1] + (1 - i / factor) * point[j][1]] for j in range(number) for i in range(factor)]\n",
    "\n",
    "\n",
    "def get_a_target_point(params):\n",
    "    waypoints = up_sampling(get_ordered_waypoints(params), 20)\n",
    "\n",
    "    car_position = [params['x'], params['y']]\n",
    "\n",
    "    distances = [distance(point, car_position) for point in waypoints]\n",
    "    min_distance = min(distances)\n",
    "    i_closest = distances.index(min_distance)\n",
    "\n",
    "    number_waypoints = len(waypoints)\n",
    "\n",
    "    waypoints_starting_with_closest = [waypoints[(i+i_closest) % number_waypoints] for i in range(number_waypoints)]\n",
    "\n",
    "    radius = params['track_width'] * 0.9\n",
    "\n",
    "    is_inside_track = [distance(p, car_position) < radius for p in waypoints_starting_with_closest]\n",
    "    i_first_outside_track = is_inside_track.index(False)\n",
    "\n",
    "    if i_first_outside_track < 0:  # this only happens if we have a radius as big as the entire track\n",
    "        return waypoints[i_closest]\n",
    "\n",
    "    return waypoints_starting_with_closest[i_first_outside_track]\n",
    "\n",
    "\n",
    "def get_target_steering_angle_degree(params):\n",
    "    target_point_x, target_point_y = get_a_target_point(params)\n",
    "    position_x = params['x']\n",
    "    position_y = params['y']\n",
    "    dx = target_point_x-position_x\n",
    "    dy = target_point_y-position_y\n",
    "    heading = params['heading']\n",
    "\n",
    "    _, target_angle = polar_coordinates(dx, dy)\n",
    "\n",
    "    steering_angle = target_angle - heading\n",
    "\n",
    "    return angle_modified_360(steering_angle)\n",
    "\n",
    "\n",
    "def score_function_steer_to_point_ahead(params):\n",
    "    optimal_stearing_angle = get_target_steering_angle_degree(params)\n",
    "    steer_angle = params['steering_angle']\n",
    "\n",
    "    error_rate = (steer_angle - optimal_stearing_angle) / 60.0  # 60 degree is already really bad\n",
    "\n",
    "    scoring = 1.0 - abs(error_rate)\n",
    "\n",
    "    return max(scoring, 0.01)  \n",
    "\n",
    "\n",
    "def reward_function(params):\n",
    "    return float(score_function_steer_to_point_ahead(params))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
